/* =========================
   Better Bullets — ROBUST RECONCILE BUILD
   - Prefix detection (fast path)
   - Persist type in block props (survives stripping)
   - Restore type from props when prefix is gone
   - Robust stripping (idempotent, removes repeated prefixes)
   - Robust UID extraction
   - Reconcile sweep across ALL visible blocks (fixes missed UID/render races)
   ========================= */

const BULLET_TYPES = [
  { id: "equal", label: 'Equal / definition (prefix "=")', prefix: "=", icon: "≡" },
  { id: "arrow", label: 'Single arrow / leads to (prefix "->")', prefix: "->", icon: "→" },
  { id: "doubleArrow", label: 'Double arrow / result (prefix "=>")', prefix: "=>", icon: "⇒" },
  { id: "question", label: 'Question (prefix "?")', prefix: "?", icon: "?" },
  { id: "important", label: 'Important / warning (prefix "!")', prefix: "!", icon: "!" },
  { id: "plus", label: 'Idea / addition (prefix "+")', prefix: "+", icon: "+" },
  { id: "downRight90", label: 'Right-angle arrow (prefix "v>")', prefix: "v>", icon: "⤷" },
  { id: "contrast", label: 'Contrast / however (prefix "~")', prefix: "~", icon: "≠" },
  { id: "evidence", label: 'Evidence / support (prefix "^")', prefix: "^", icon: "▸" },
  { id: "conclusion", label: 'Conclusion / synthesis (prefix "∴")', prefix: "∴", icon: "∴" },
  { id: "hypothesis", label: 'Hypothesis / tentative (prefix "??")', prefix: "??", icon: "◊" },
  { id: "depends", label: 'Depends on / prerequisite (prefix "<-")', prefix: "<-", icon: "↤" },
  { id: "decision", label: 'Decision / choice (prefix "|")', prefix: "|", icon: "⎇" },
  { id: "reference", label: 'Reference / related (prefix "@")', prefix: "@", icon: "↗" },
  { id: "process", label: 'Process / ongoing (prefix "...")', prefix: "...", icon: "↻" },
];

const bulletSettings = {
  enabled: {}, // id -> boolean
  stripMarkers: false,
};

let observer = null;
let stripWorkerTimer = null;
let reconcileTimer = null;

const stripQueue = new Map(); // uid -> bulletTypeId

const PERSIST_PROP_TYPE_KEYS = [
  "::better-bullets/type",
  ":better-bullets/type",
  "better-bullets/type",
  "::better-bullets",
  ":better-bullets",
  "better-bullets",
];

const PERSIST_WRITE_KEY = "better-bullets/type";

/* =========================
   Utilities
   ========================= */

function escapeRegExp(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function stripLeadingInvisibles(text) {
  return String(text || "").replace(
    /^[\s\u00A0\u202F\u200B\u200C\u200D\uFEFF\u2060\u200E\u200F\u202A-\u202E\u2066-\u2069]+/,
    ""
  );
}

function isBulletTypeEnabled(id) {
  if (Object.prototype.hasOwnProperty.call(bulletSettings.enabled, id)) {
    return !!bulletSettings.enabled[id];
  }
  return true; // default ON
}

function getBulletTypeById(id) {
  return BULLET_TYPES.find((b) => b.id === id) || null;
}

/**
 * Robust UID extraction:
 * - Looks for any element with id containing "block-input-" and a 9-char uid suffix
 * - Falls back to any id ending in -<9chars>
 */
function getBlockUidFromContainer(container) {
  if (!container?.querySelectorAll) return null;

  const tryExtract = (id) => {
    if (typeof id !== "string") return null;
    const m = id.match(/-([A-Za-z0-9]{9})$/);
    return m ? m[1] : null;
  };

  // Most common: rm-block__input / rm-block-text ids
  const candidates = [
    container.querySelector(".rm-block__input[id^='block-input-']"),
    container.querySelector(".rm-block-text[id^='block-input-']"),
    container.querySelector("[id^='block-input-']"),
  ].filter(Boolean);

  for (const el of candidates) {
    const uid = tryExtract(el.id);
    if (uid) return uid;
  }

  // Broader: anything with "block-input-" in id
  const all = container.querySelectorAll("[id*='block-input-']");
  for (const el of all) {
    const uid = tryExtract(el.id);
    if (uid) return uid;
  }

  // Last resort: any id ending in -<uid>
  const allWithId = container.querySelectorAll("[id]");
  for (const el of allWithId) {
    const uid = tryExtract(el.id);
    if (uid) return uid;
  }

  return null;
}

function getBulletTypeByPrefixFromString(blockString) {
  const trimmed = stripLeadingInvisibles(blockString);
  for (const bt of BULLET_TYPES) {
    if (!isBulletTypeEnabled(bt.id)) continue;
    const re = new RegExp(
      `^${escapeRegExp(bt.prefix)}(?:[\\s\\u00A0\\u200B\\u200C\\u200D\\uFEFF]|$)`
    );
    if (re.test(trimmed)) return bt;
  }
  return null;
}

function safeUpdateBlock(payload) {
  if (!window.roamAlphaAPI?.updateBlock) return;
  try {
    const res = window.roamAlphaAPI.updateBlock(payload);
    if (res?.catch) res.catch(() => {});
  } catch {
    // ignore
  }
}

/* =========================
   Persistence (props)
   ========================= */

function getPropValue(props, keys) {
  if (!props) return undefined;
  for (const k of keys) {
    if (Object.prototype.hasOwnProperty.call(props, k)) return props[k];
  }
  return undefined;
}

function readPersistedType(uid) {
  if (!window.roamAlphaAPI || !uid) return null;
  try {
    const pulled = window.roamAlphaAPI.pull("[:block/props]", [":block/uid", uid]);
    const props = pulled?.[":block/props"];
    const typeId = getPropValue(props, PERSIST_PROP_TYPE_KEYS);
    return typeof typeId === "string" && typeId ? typeId : null;
  } catch {
    return null;
  }
}

function persistType(uid, bulletType) {
  if (!window.roamAlphaAPI || !uid || !bulletType) return;
  safeUpdateBlock({
    block: {
      uid,
      props: {
        [PERSIST_WRITE_KEY]: bulletType.id,
      },
    },
  });
}

/* =========================
   DOM application
   ========================= */

function clearBetterBulletClasses(container) {
  const toRemove = [];
  container.classList.forEach((c) => {
    if (c.startsWith("better-bullet-")) toRemove.push(c);
  });
  toRemove.forEach((c) => container.classList.remove(c));
}

function applyBullet(container, bulletType) {
  clearBetterBulletClasses(container);

  if (!bulletType) {
    container.removeAttribute("data-better-bullet");
    return;
  }

  container.classList.add(`better-bullet-${bulletType.id}`);
  container.setAttribute("data-better-bullet", bulletType.id);
}

/* =========================
   Stripping (idempotent, repeatable, verified)
   ========================= */

function buildStripRegex(prefix) {
  // Remove:
  // [invis+space] (prefix [invis+space])* repeated (to kill duplicates)
  return new RegExp(
    `^[\\s\\u00A0\\u202F\\u200B\\u200C\\u200D\\uFEFF\\u2060\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]*(?:${escapeRegExp(
      prefix
    )}[\\s\\u00A0\\u202F\\u200B\\u200C\\u200D\\uFEFF\\u2060\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]*)+`
  );
}

async function stripMarkerFromUid(uid, bulletType) {
  if (!window.roamAlphaAPI) return false;
  if (!uid || !/^[A-Za-z0-9]{9}$/.test(uid)) return false;

  const prefix = bulletType?.prefix;
  if (!prefix) return false;

  const re = buildStripRegex(prefix);

  // Read DB truth
  let pulled = window.roamAlphaAPI.pull("[:block/string]", [":block/uid", uid]);
  let orig = pulled?.[":block/string"];
  if (typeof orig !== "string") return false;

  // Already clean
  if (!re.test(orig)) return true;

  const next = orig.replace(re, "");
  if (next === orig) return true;

  // Write
  await Promise.resolve(window.roamAlphaAPI.updateBlock({ block: { uid, string: next } }));

  // Verify (Roam can replay buffers)
  await new Promise((r) => setTimeout(r, 90));
  pulled = window.roamAlphaAPI.pull("[:block/string]", [":block/uid", uid]);
  const after = pulled?.[":block/string"];
  if (typeof after !== "string") return false;

  if (re.test(after)) return false; // keep queued
  return true;
}

/* =========================
   Strip Queue Worker
   ========================= */

function startStripWorker() {
  if (stripWorkerTimer) return;
  stripWorkerTimer = setInterval(async () => {
    if (!bulletSettings.stripMarkers) return;
    if (!window.roamAlphaAPI) return;
    if (stripQueue.size === 0) return;

    const active = document.activeElement;
    const activeUid =
      active?.closest?.(".roam-block-container") &&
      getBlockUidFromContainer(active.closest(".roam-block-container"));

    let processed = 0;
    for (const [uid, typeId] of stripQueue) {
      if (processed >= 12) break;
      if (!uid || !/^[A-Za-z0-9]{9}$/.test(uid)) {
        stripQueue.delete(uid);
        continue;
      }
      if (activeUid && uid === activeUid) continue;

      const bt = getBulletTypeById(typeId);
      if (!bt) {
        stripQueue.delete(uid);
        continue;
      }

      try {
        const ok = await stripMarkerFromUid(uid, bt);
        if (ok) stripQueue.delete(uid);
      } catch {
        // keep queued
      }

      processed++;
    }
  }, 200);
}

function stopStripWorker() {
  if (!stripWorkerTimer) return;
  clearInterval(stripWorkerTimer);
  stripWorkerTimer = null;
}

/* =========================
   Reconcile Sweep (the missing glue)
   - Runs across ALL visible blocks
   - Uses DB truth when UID exists
   - Ensures persistence + stripping are eventually consistent
   ========================= */

function startReconcileSweep() {
  if (reconcileTimer) return;
  reconcileTimer = setInterval(() => {
    const containers = document.querySelectorAll(".roam-block-container");
    containers.forEach((container) => reconcileContainer(container));
  }, 650);
}

function stopReconcileSweep() {
  if (!reconcileTimer) return;
  clearInterval(reconcileTimer);
  reconcileTimer = null;
}

function reconcileContainer(container) {
  if (!container?.isConnected) return;

  const uid = getBlockUidFromContainer(container);

  // Fast path (no uid yet): use DOM text only for immediate icon feedback
  // (stripping/persist will happen once uid exists)
  const textEl = container.querySelector(".rm-block-text");
  const domText = textEl?.innerText || "";
  const domDetected = domText ? getBulletTypeByPrefixFromString(domText) : null;

  if (!uid) {
    if (domDetected) applyBullet(container, domDetected);
    return;
  }

  // DB truth: string + props
  let dbString = null;
  try {
    const pulled = window.roamAlphaAPI.pull("[:block/string :block/props]", [":block/uid", uid]);
    dbString = pulled?.[":block/string"];
  } catch {
    // fall back to DOM only
  }

  const dbDetected = typeof dbString === "string" ? getBulletTypeByPrefixFromString(dbString) : null;

  // 1) If DB string begins with a prefix, that is authoritative
  if (dbDetected) {
    if (isBulletTypeEnabled(dbDetected.id)) {
      applyBullet(container, dbDetected);
      persistType(uid, dbDetected);

      if (bulletSettings.stripMarkers) {
        stripQueue.set(uid, dbDetected.id);
        startStripWorker();
      }
      return;
    } else {
      applyBullet(container, null);
      return;
    }
  }

  // 2) Else: restore from persisted props (if any)
  const persistedId = readPersistedType(uid);
  const persistedBt = persistedId ? getBulletTypeById(persistedId) : null;

  if (persistedBt && isBulletTypeEnabled(persistedBt.id)) {
    applyBullet(container, persistedBt);
    return;
  }

  // 3) Nothing applies
  applyBullet(container, null);
}

/* =========================
   Mutation observer (for responsiveness)
   ========================= */

function getClosestContainerFromNode(node) {
  if (!node) return null;
  if (node.nodeType === 1 && node.classList?.contains("roam-block-container")) return node;
  return node.closest ? node.closest(".roam-block-container") : null;
}

function startObserver() {
  if (observer) return;

  observer = new MutationObserver((muts) => {
    const seen = new Set();
    for (const m of muts) {
      if (m.type === "characterData") {
        const c = getClosestContainerFromNode(m.target.parentElement);
        if (c) seen.add(c);
      }
      if (m.addedNodes?.length) {
        m.addedNodes.forEach((n) => {
          const c = getClosestContainerFromNode(n);
          if (c) seen.add(c);
          if (n.querySelectorAll) {
            n.querySelectorAll(".roam-block-container").forEach((inner) => seen.add(inner));
          }
        });
      }
    }
    // immediate UI update; persistence/strip is handled by reconcile sweep
    seen.forEach((c) => {
      const textEl = c.querySelector(".rm-block-text");
      const raw = textEl?.innerText || "";
      const bt = raw ? getBulletTypeByPrefixFromString(raw) : null;
      if (bt && isBulletTypeEnabled(bt.id)) applyBullet(c, bt);
    });
  });

  observer.observe(document.body, {
    subtree: true,
    childList: true,
    characterData: true,
  });
}

function stopObserver() {
  observer?.disconnect();
  observer = null;
}

/* =========================
   Settings
   ========================= */

function buildSettings(extensionAPI) {
  const settings = [];

  settings.push({
    id: "bb-strip-markers",
    name: "Strip marker prefix from text",
    description:
      'If enabled, the marker at the start of a block (e.g., "->", "=>", "??", "...") will be removed from the text after recognition. Bullet type is preserved via block props.',
    action: {
      type: "switch",
      onChange: (e) => {
        const enabled = !!(e?.target?.checked ?? e?.value ?? e);
        bulletSettings.stripMarkers = enabled;
        extensionAPI.settings.set("bb-strip-markers", enabled);

        if (enabled) startStripWorker();

        // trigger a quick reconcile pass now
        document.querySelectorAll(".roam-block-container").forEach(reconcileContainer);
      },
    },
  });

  BULLET_TYPES.forEach((bt) => {
    settings.push({
      id: `bb-enable-${bt.id}`,
      name: `Enable: ${bt.label}`,
      description: "Toggle this bullet type.",
      action: {
        type: "switch",
        onChange: (e) => {
          const enabled = !!(e?.target?.checked ?? e?.value ?? e);
          bulletSettings.enabled[bt.id] = enabled;
          extensionAPI.settings.set(`bb-enable-${bt.id}`, enabled);

          // reconcile everything so disabled types disappear
          document.querySelectorAll(".roam-block-container").forEach(reconcileContainer);
        },
      },
    });
  });

  extensionAPI.settings.panel.create({
    tabTitle: "Better Bullets",
    settings,
  });

  bulletSettings.stripMarkers = extensionAPI.settings.get("bb-strip-markers") === true;

  BULLET_TYPES.forEach((bt) => {
    const stored = extensionAPI.settings.get(`bb-enable-${bt.id}`);
    bulletSettings.enabled[bt.id] = stored !== false;
  });
}

/* =========================
   Lifecycle
   ========================= */

export default {
  onload: ({ extensionAPI }) => {
    buildSettings(extensionAPI);

    startObserver();
    startStripWorker();
    startReconcileSweep();

    // initial reconcile
    document.querySelectorAll(".roam-block-container").forEach(reconcileContainer);
  },

  onunload: () => {
    stopObserver();
    stopReconcileSweep();
    stopStripWorker();
    stripQueue.clear();

    document.querySelectorAll(".roam-block-container").forEach((c) => {
      clearBetterBulletClasses(c);
      c.removeAttribute("data-better-bullet");
    });
  },
};
